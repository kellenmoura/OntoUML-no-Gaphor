# This file is generated by profile_coder.py. DO NOT EDIT!
from __future__ import annotations

import uuid
from typing import TYPE_CHECKING, Callable, List, Optional

from gaphor.core.modeling.properties import (
    association,
    attribute,
    derived,
    derivedunion,
    enumeration,
    redefine,
    relation_many,
    relation_one,
)
from gaphor.core.modeling import (
    Comment,
    Diagram,
    Element,
    NamedElement,
    PackageableElement,
    StyleSheet,
)
from gaphor.UML import (
    Abstraction,
    AcceptEventAction,
    ActivityEdge,
    ActivityPartition,
    ActivityGroup,
    Activity,
    Action,
    Artifact,
    AddStructuralFeatureValueAction,
    Behavior,
    ChangeEvent,
    Class,
    Classifier,
    Comment,
    Component,
    Connector,
    ConnectorEnd,
    Constraint,
    DataType,
    Dependency,
    DirectedRelationship,
    DeploymentTarget,
    Element,
    ElementImport,
    Extend,
    Feature,
    Generalization,
    GeneralOrdering,
    InstanceSpecification,
    InvocationAction,
    Include,
    Interaction,
    InteractionFragment,
    NamedElement,
    Namespace,
    ObjectNode,
    Operation,
    Optional,
    Parameter,
    ParameterSet,
    PackageImport,
    PackageMerge,
    Package,
    Port,
    Property,
    Pseudostate,
    RedefinableElement,
    Realization,
    StructuralFeature,
    State,
    StateInvariant,
    Stereotype,
    Substitution,
    Slot,
    Transition,
    Trigger,
    Type,
)

class Classifier(Namespace, Type, RedefinableElement):
    isAbstract: attribute[int]
    ownedUseCase: relation_many[UseCase]
    generalization: relation_many[Generalization]
    Heritage: relation_many[Heritage]
    useCase: relation_many[UseCase]
    redefinedClassifier: relation_many[Classifier]
    substitution: relation_many[Substitution]
    attribute: relation_many[Property]
    feature: relation_many[Feature]
    general: derived[Classifier]
    inheritedMember: derivedunion[NamedElement]


class Heritage(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Dependencyblack(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Dependencywhite(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Formal(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Material(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Mediation(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Characterization(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Derivation(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Structuration(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Partwhole(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Partwholeblack(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Memberof(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Memberofblack(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Subcollectionof(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Subquantityof(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Componentof(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class Containment(DirectedRelationship):
    isSubstitutable: attribute[int]
    general: relation_one[Classifier]
    specific: relation_one[Classifier]

class AcceptChangeStructuralFeatureEventAction(AcceptEventAction):
    pass


class ElementPropertyPath(Element):
    propertyPath: relation_many[Property]


class AddFlowPropertyValueOnNestedPortAction(
    AddStructuralFeatureValueAction, ElementPropertyPath
):
    pass


class AdjuntProperty(Property):
    principal: relation_one[Element]


class DirectedRelationshipPropertyPath(DirectedRelationship):
    sourcePropertyPath: relation_many[Property]
    targetContext: relation_one[Classifier]
    targetPropertyPath: relation_many[Property]
    sourceContext: relation_one[Classifier]


class Allocate(Abstraction, DirectedRelationshipPropertyPath):
    pass


class AllocateActivityPartition(ActivityPartition):
    pass


class BindingConnector(Connector):
    pass


class EndPathMultiplicity(Property):
    pass


class BoundReference(EndPathMultiplicity):
    boundend: relation_many[ConnectorEnd]


class ChangeSructuralFeatureEvent(ChangeEvent):
    structuralFeature: relation_one[StructuralFeature]


class ClassifierBehaviorProperty(Property):
    pass


class Conform(Generalization):
    pass


class ConnectorProperty(Property):
    connector: relation_one[Connector]


class Rate(ActivityEdge, Parameter):
    rate: relation_many[InstanceSpecification]


class Continuous(Rate):
    pass


class ControlOperator(Behavior):
    pass


class Trace(Dependency, DirectedRelationshipPropertyPath):
    pass


class Copy(Trace):
    pass


class DeriveReqt(Trace):
    pass


class DirectedFeature(Feature):
    featureDirection: enumeration


class Discrete(Rate):
    pass


class DistributedProperty(Property):
    pass


class ElementGroup(Comment):
    name: attribute[str]
    orderedMember: relation_many[Element]


class Expose(Dependency):
    pass


class FlowProperty(Property):
    direction: enumeration


class FullPort(Port):
    pass


class InvocationOnNestedPortAction(ElementPropertyPath, InvocationAction):
    onNestedPort: relation_many[Port]


class NestedConnectorEnd(ConnectorEnd, ElementPropertyPath):
    pass


class NoBuffer(ObjectNode):
    pass


class Overwrite(ObjectNode):
    pass


class ParticipantProperty(Property):
    end_: relation_one[Property]


class Probability(ActivityEdge, ParameterSet):
    probability: attribute[str]


class Problem(Comment):
    pass


class PropertySpecificType(Classifier):
    pass


class ProxyPort(Port):
    pass


class Rationale(Comment):
    pass


class Refine(Dependency, DirectedRelationshipPropertyPath):
    pass


class Satisfy(Trace):
    pass


class Stakeholder(Classifier):
    concernList: relation_many[Comment]


#aqui foram adicionados estere√≥tipos da ontouml
class StereotypeKind(Class):
    pass

class StereotypeSubkind(Class):
    pass

class StereotypePhase(Class):
    pass

class StereotypeRole(Class):
    pass

class StereotypeCollective(Class):
    pass

class StereotypeQuantity(Class):
    pass

class StereotypeRelator(Stereotype):
    pass

class StereotypeCategory(Class):
    pass

class StereotypeRolemixin(Class):
    pass

class StereotypeMixin(Class):
    pass

class StereotypePhasemixin(Class):
    pass

class StereotypeMode(Class):
    pass

class StereotypeQuality(Class):
    pass
    

class Tagged(Property):
    nonunique: relation_many[bool]
    ordered: relation_many[bool]
    subsets: attribute[str]


class TestCase(Behavior):
    pass


class TriggerOnNestedPort(ElementPropertyPath, Trigger):
    onNestedPort: relation_many[Port]


class ValueType(DataType):
    quantityKind: relation_one[InstanceSpecification]
    unit: relation_one[InstanceSpecification]


class Verify(Trace):
    pass


class View(Class):
    pass


class Viewpoint(Class):
    concernList: relation_many[Comment]
    language: attribute[str]
    presentation: attribute[str]
    purpose: attribute[str]
    stakeholder: relation_many[Stakeholder]


Heritage.isSubstitutable = attribute("isSubstitutable", int)
ObjectNode.ordering = enumeration(
    "ordering", ("unordered", "ordered", "LIFO", "FIFO"), "FIFO"
)
Heritage.general = association("general", Classifier, lower=1, upper=1)
Classifier.heritage = association(
    "heritage", Heritage, composite=True, opposite="specific"
)
Heritage.specific = association(
    "specific", Classifier, lower=1, upper=1, opposite="heritage"
)
Classifier.general = derived(
    "general", Classifier, 0, "*", lambda self: [g.general for g in self.heritage]
)
DirectedRelationship.target = derivedunion(
    "target",
    Element,
    1,
    "*",
    PackageImport.importedPackage,
    PackageMerge.mergedPackage,
    Heritage.general,
    Include.addition,
    Extend.extendedCase,
    Realization.realizingClassifier,
    ElementImport.importedElement,
    Substitution.contract,
)
DirectedRelationship.source = derivedunion(
    "source",
    Element,
    1,
    "*",
    Extend.extension,
    Realization.abstraction,
    Substitution.substitutingClassifier,
    Include.includingCase,
    ElementImport.importingNamespace,
    Heritage.specific,
    PackageImport.importingNamespace,
    PackageMerge.mergingPackage,
)
Element.owner = derivedunion(
    "owner",
    Element,
    0,
    1,
    Slot.owningInstance,
    Realization.abstraction,
    ElementImport.importingNamespace,
    Heritage.specific,
    ActivityEdge.activity,
    ActivityGroup.superGroup,
    ActivityGroup.activity,
    PackageImport.importingNamespace,
    PackageMerge.mergingPackage,
    NamedElement.namespace,
    Constraint.stateInvariant,
    Pseudostate.state,
    Action.interaction,
    GeneralOrdering.interactionFragment,
    Constraint.parameterSet,
)
Element.ownedElement = derivedunion(
    "ownedElement",
    Element,
    0,
    "*",
    Artifact.manifestation,
    Element.ownedComment,
    Action.input,
    Classifier.heritage,
    Namespace.ownedMember,
    Namespace.elementImport,
    Activity.group,
    Component.realization,
    Namespace.packageImport,
    Package.packageExtension,
    Substitution.contract,
    ActivityGroup.subgroup,
    Activity.edge,
    Activity.node,
    Action.output,
    StateInvariant.invariant,
    Connector.end,
    State.entry,
    State.exit,
    State.doActivity,
    Transition.effect,
    State.statevariant,
    Transition.guard,
    DeploymentTarget.deployment,
    Interaction.action,
    InteractionFragment.generalOrdering,
    ParameterSet.condition,
)


AdjuntProperty.principal = association("principal", Element, upper=1)
BoundReference.boundend = association("boundend", ConnectorEnd, upper=1)
ChangeSructuralFeatureEvent.structuralFeature = association(
    "structuralFeature", StructuralFeature, upper=1
)
ConnectorProperty.connector = association("connector", Connector, upper=1)
DirectedFeature.featureDirection = enumeration(
    "kind", ("providedRequired", "provided", "required"), "providedRequired"
)
DirectedRelationshipPropertyPath.sourceContext = association(
    "sourceContext", Classifier, upper=1
)
DirectedRelationshipPropertyPath.sourcePropertyPath = association(
    "sourcePropertyPath", Property
)
DirectedRelationshipPropertyPath.targetContext = association(
    "targetContext", Classifier, upper=1
)
DirectedRelationshipPropertyPath.targetPropertyPath = association(
    "targetPropertyPath", Property
)
ElementGroup.name = attribute("name", str)
ElementGroup.orderedMember = association("orderedMember", Element)
ElementPropertyPath.propertyPath = association("propertyPath", Property, lower=1)
FlowProperty.direction = enumeration("kind", ("inout", "in", "out"), "inout")
InvocationOnNestedPortAction.onNestedPort = association("onNestedPort", Port, lower=1)
ParticipantProperty.end_ = association("end_", Property, upper=1)
Probability.probability = attribute("probability", str)
Rate.rate = association("rate", InstanceSpecification, upper=1)
Stakeholder.concernList = association("concernList", Comment)
Tagged.nonunique = association("nonunique", bool, upper=1)
Tagged.ordered = association("ordered", bool, upper=1)
Tagged.subsets = attribute("subsets", str)
TriggerOnNestedPort.onNestedPort = association("onNestedPort", Port, lower=1)
ValueType.quantityKind = association("quantityKind", InstanceSpecification, upper=1)
ValueType.unit = association("unit", InstanceSpecification, upper=1)
Viewpoint.concernList = association("concernList", Comment)
Viewpoint.language = attribute("language", str)
Viewpoint.presentation = attribute("presentation", str)
Viewpoint.purpose = attribute("purpose", str)
Viewpoint.stakeholder = association("stakeholder", Stakeholder)
